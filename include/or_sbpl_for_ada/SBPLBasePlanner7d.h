#ifndef SBPL_BASE_PLANNER_H_
#define SBPL_BASE_PLANNER_H_

#include "ros/ros.h"
#include "std_msgs/String.h"

#include <boost/shared_ptr.hpp>
#include <boost/thread.hpp>

#include <sbpl/config.h>
#include <sbpl/planners/planner.h>

#include <or_sbpl_for_ada/SBPLBasePlannerEnvironment7d.h>

#include <openrave/openrave.h>
#include <openrave/planner.h>

#include <string>
#include <vector>
#include <algorithm>
#include <iterator>
#include <iostream>
#include <cassert>
#include <sstream>


namespace or_sbpl_for_ada {

    typedef boost::shared_ptr<SBPLPlanner> SBPLPlannerPtr;

    /**
     * A wrapper that exposes the SBPL planner for the base as an OpenRAVE planner
     */
    class SBPLBasePlanner : public OpenRAVE::PlannerBase  {

    public:
	/**
	 * Constructor
	 *
	 * @param penv The OpenRAVE environment this planner will be run in
	 */
        SBPLBasePlanner(OpenRAVE::EnvironmentBasePtr penv);
	
	/**
	 * Destructor
	 */
        virtual ~SBPLBasePlanner();

	/**
	 * Initialize the planner
	 * 
	 * @param robot The OpenRAVE robot to plan for
	 * @param params The parameters of the planner
	 */
        virtual bool InitPlan(OpenRAVE::RobotBasePtr robot, PlannerParametersConstPtr params);

	/**
	 * Initialize the planner
	 * 
	 * @param robot The OpenRAVE robot to plan for
	 * @param input A stream to read planner parameters from
	 */
        virtual bool InitPlan(OpenRAVE::RobotBasePtr robot, std::istream& input);

	/**
	 * Run the planner
	 * 
	 * @param ptraj The trajectory that is generated by this planner
	 * @return The status of the planning
	 */
        virtual OpenRAVE::PlannerStatus PlanPath(OpenRAVE::TrajectoryBasePtr ptraj);
	
	/**
	 * @return The parameters for the planner
	 */
        virtual PlannerParametersConstPtr GetParameters() const { return _params; }
        

    private:

	void print_start_DOF();
	void print_start_cart(std::vector<OpenRAVE::dReal> start_pos);
	OpenRAVE::PlannerStatus best_mode( std::vector<float> &mode_cost, ReplanParams rparams, 
		OpenRAVE::TrajectoryBasePtr ptraj, std::vector<int>& plan, std::vector<OpenRAVE::dReal> start_pos);
	OpenRAVE::PlannerStatus init_plan();

	void start_listener();
	void chatterCallback(const std_msgs::String::ConstPtr& msg);
	ros::Publisher init_path_cost_publisher();
	std_msgs::String floatToStringToPub( std::vector<float> mode_cost );
 
	void AddWaypoint(OpenRAVE::TrajectoryBasePtr ptraj, const OpenRAVE::ConfigurationSpecification &config_spec,
			 const double &x, const double &y, const double &z, const double &theta, const double &phi,const double &psi,const int &mode) const;
	bool GetPathCost(std::ostream &out, std::istream &in);
	bool GetPathsCosts(std::ostream &out, std::istream &in);
	bool GetCartPath(std::ostream &out, std::istream &in);
	bool GetListActions(std::ostream &out, std::istream &in);

        OpenRAVE::EnvironmentBasePtr _orenv;
        OpenRAVE::RobotBasePtr _robot;
        PlannerParametersConstPtr _params;
        SBPLPlannerPtr _planner;
        SBPLBasePlannerEnvironmentPtr _env;

        std::vector<WorldCoordinate> _cart_path;
        std::vector<WorldCoordinate> _list_actions;

	float _cost[3];
    double _path_cost;    
	double _maxtime;
	double _maxtime_temp;
	double _epsinit;
	double _epsdec;
	int _n_axes;
	bool _return_first;
	bool _initialized;
    
    };
    
    typedef boost::shared_ptr<SBPLBasePlanner> SBPLBasePlannerPtr;

}


#endif

